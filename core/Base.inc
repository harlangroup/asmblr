<?php
/**
 * @file Base.inc Base classes.
 * @author Stackware, LLC
 * @version 4.0
 * @copyright Copyright (c) 2012-2014 Stackware, LLC. All Rights Reserved.
 * @copyright Licensed under the GNU General Public License
 * @copyright See COPYRIGHT.txt and LICENSE.txt.
 */
namespace asm;


/**
 * Apply a Directive to the object.
 *
 * The affect of applying a Directive is determined only by the object itself.
 *
 * @param string $Key The Key to set.
 * @param mixed $Value The Value to set.
 * @retval void
 */
// public function ApplyDirective( $Key,$Value );

interface Debuggable
{
    /**
     * Turn on debugging for the Wire()'d object.
     *
     * Debugging behavior is determined only by the object itself and should
     * be on when a configured DebugToken is present in $_SERVER.
     *
     * Implementations of this method should typically check that the object
     * has already been App::Wire()'d.
     */
    public function DebugOn( $Label = NULL );

    /**
     * Turn off debugging for the Wire()'d object.
    */
    public function DebugOff();

}



trait Debugged
{
    /**
     * Token for toggling debugging for the object.
     * It can be checked using \c isset($_SERVER[$this->DebugToken])
     */
    protected $DebugToken;

    /**
     * Enable debugging.
     *
     * @param NULL $Label Log messages will be labeled with the class name.
     * @param string $Label Custom label for log messages.
     * @throws Exception
     */
    public function DebugOn( $Label = NULL )
    {
        if( empty($Label) )
            $this->DebugToken = get_class($this);

        $_SERVER[$this->DebugToken] = TRUE;
    }

    /**
     * Disable debugging.
     */
    public function DebugOff()
    {
        if( !empty($this->DebugToken) )
            unset($_SERVER[$this->DebugToken]);
    }

    /**
     * Determine whether is enabled.
     */
    public function IsDebug()
    {
        return !empty($_SERVER[$this->DebugToken]);
    }
}



/**
 * Interface for classes which wish to manipulate a set key/value pairs.
 */
interface KVS extends \Iterator,\Countable,\ArrayAccess
{
    public function __get( $Key );

    public function __set( $Key,$Value );

    public function __isset( $Key );

    public function __unset( $Key );

    public function Export();
}



/**
 * Interface for classes which wish to implement CREATE, READ, UPDATE,
 * DELETE and COUNT functionality on a data source.
 *
 * Depending on the data source, each method may affect one or more than one
 * records.  CREATE, UPDATE and DELETE affect only one row for Mongo but
 * multiple rows for MySQL.  READ and COUNT looks at multiple rows for
 * both databases.
 *
 * @note This might be deprecated.
 */
interface CRUDC
{
    public function CREATE( $Table,$Values );
    public function READ( $Table,$Constraint = NULL,$Columns = NULL,$OrderBy = NULL );
    public function UPDATE( $Table,$Values,$Constraint );
    public function DELETE( $Table,$Constraint );
    public function COUNT( $Table,$Constraint = NULL );
}



/**
 * Namespace-local exception.
 *
 * Thrown internally by Framewire.
 */
class Exception extends \Exception
{
}



/**
 * Log messages to a destination.
 *
 * Log can send messages to the following destinations:
 *  - Sys: web server (SAPI) logging mechanism.
 *  - Email: to the SysOp or custom address.
 *  - Wildfire: FirePHP HTTP header protocol for browser console debugging.
 *  - ChromePHP: HTTP header protocol for browser console debugging.
 *
 * The Sys and Email mechanisms are considered private logging.  If
 * App::$LogPublic is set to TRUE, Wildfire/ChromePHP logging will be
 * automatically detected and used if available, or fallback to Sys.
 *
 * The following levels are available: 'LOG','INFO','WARN','ERROR'.
 * The effect of each depends on the destination..
 *
 * Provides logging and notification functionality.
 *
 * @note Under IIS, set the php.ini directive error_log="php_errors.log"
 * 		 which will log errors to c:\\windows\\temp\\php_errors.log
 * @note Under Apache/lighttpd/etc, errors will be logged by default to the
 * 		 web server's log file for the virtual host, or global log file.
 */
/**
 * Error handling falls into:
 *  - user errors/warnings - generated by trigger_error() or Log methods, these messages are delivered
 *    automatically to the optimal logging destination.
 *  - PHP fatal errors - caught upon shutdown, they are delivered as ERRORs to the optimal logging destination.
 *  - Exception - caught exceptions can be logged similar to any other message.
 *  - Uncaught exceptions - automatically logged using the optimal logging destination.
 */

abstract class Log
{
    /**
     * Log a message using an optimal destination.
     *
     * Log::Log() will deliver a message to an automatically determined
     * mechanism, based on these criteria:
     *  - If IsCLI is TRUE, Log::Sys() is used.
     *  - If LogPublic is TRUE, detect FirePHP or ChromePHP plugin and output
     *    using Log::Wildfire() or Log::ChromePHP().
     *  - Fallback to Log::Sys().
     *
     * Logging should be funneled through this method to ensure log
     * configuration (App::$LogPublic) is correctly honored.
     *
     * The global function llog() is shorthand for this method, Log::Log(),
     * and is meant as a replacement for var_dump().
     *
     * @param string $Msg The message to log.
     * @param mixed $Msg An array or object to log - non-scalar output depends on destination.
     * @param string $Level The message severity (LOG, INFO, WARN, ERROR).
     * @param string $Backtrace A string indicating where the message originated.
     * @param array $Backtrace A backtrace array (array of strings).
     * @param array $Context Local variables from the scope in which the message originated.
     *
     * @note This expects that the error handlers and Request are already initialized.
     * @todo Add Email support.
     */
    public static function Log( $Msg,$Level = 'LOG',$Backtrace = NULL,$Context = NULL )
    {
        global $asmapp;

        $IsCLI = $asmapp->Request['IsCLI'];
        $LogPublic = $asmapp->Config['LogPublic'];

        if( count(debug_backtrace()) > 100 )
        {
            trigger_error("Sorry, logging is apparently stuck in recursion (100+ deep) - bye.\r\n\r\n".Debug::Dump(Debug::Backtrace()),'ERROR',debug_backtrace(),NULL);
            exit;
        }

        // If the first backtrace line is a string, we take it as where an error occurred.
        if( is_array($Backtrace) && Is::String(0,$Backtrace) )
            $Msg .= " {$Backtrace[0]}";

        $Context = (array) $Context;

        // Always add the requested URL as part of the context
        $Context['Request'] = URL::ToString($asmapp->Request);

        // CLI - use Log::Sys() - other option would be Email
        if( $IsCLI === TRUE )
        {
            Log::Sys($Msg,$Level,$Backtrace,$Context);
        }
        else
        {

            // detect FirePHP or ChromePHP or fallback to Log::Sys()
            // NOTE:  Chrome PHP doesn't announce itself so we're not supporting it anymore
            if( $LogPublic === TRUE )
            {
                if( Request::IsFirePHP() )
                    Log::Wildfire($Msg,$Level,$Backtrace,$Context);
//                else if( Request::IsChromePHP() )
//                    Log::ChromePHP($Msg,$Level,$Backtrace,$Context);
                else
                    Log::Sys($Msg,$Level,$Backtrace,$Context);
            }
            // log internally using Log::Sys() - other option would be Email
            else
            {
                Log::Sys($Msg,$Level,$Backtrace,$Context);
            }
        }
    }

    /**
     * Log a message to the SAPI's default logging mechanism.
     *
     * This is a private logging destination.
     *
     * @param string $Msg The message to log.
     * @param mixed $Msg An array or object to log - non-scalars will be dumped as a string.
     * @param string $Level The message severity (LOG, INFO, WARN, ERROR).
     * @param string $Backtrace A string indicating where the message originated.
     * @param array $Backtrace A backtrace array (array of strings).
     * @param array $Context Local variables from the scope in which the message originated.
     *
     * @note This uses error_log() 0 and 4 on Windows and Linux, respectively.
     * @todo Context and Backtrace are currently ignored.
     * @todo Do we want to use syslog() instead (for GAE PHP)?
     */
    public static function Sys( $Msg,$Level = 'LOG',$Backtrace = NULL,$Context = NULL )
    {
        if( !is_string($Msg) )
            $Msg = Debug::Dump($Msg);

        // CLI - always direct
        if( Request::Init()['IsCLI'] === TRUE )
        {
            error_log("\r\n".str_replace(array("\r\n","\n"),"\r\n",$Msg),4);
        }
        // We're on Windows so do it all in one shot and change line endings - assumes IIS - goes to php.log file
        else if( App::IsWindows() === TRUE )
        {
            error_log(str_replace(array("\r\n","\n"),"\r\n",$Msg),0);
        }
        // Assume Linux and log line-by-line for easier reading.
        else
        {
            foreach( explode("\n",trim($Msg) ) as $Line )
                error_log($Line,4);
        }
    }

    /**
     * Log a message by sending an email.
     *
     * By default the email is sent to the configured value of App::$SysOp.
     *
     * If sending fails, the messages is logged to Log::Sys().
     *
     * @param string $Msg The message to log.
     * @param mixed $Msg An array or object to log - non-scalars will be dumped as a string.
     * @param string $Level The message severity (LOG, INFO, WARN, ERROR).
     * @param string $Backtrace A string indicating where the message originated.
     * @param array $Backtrace A backtrace array (array of strings).
     * @param array $Context Local variables from the scope in which the message originated.
     * @param string $Email Optional email address to send to instead of App::$SysOp.
     */
    public static function Email( $Msg,$Level = 'LOG',$Backtrace = NULL,$Context = NULL,$Email = NULL )
    {
        if( !empty($Email) )
            $To = $Email;
        else
            $To = fw()->SysOp;

        $From = fw()->SysOp;
        $FromDisplay = "Framewire <{$From}>";

        if( !is_string($Msg) )
            $Msg = Debug::Dump($Msg);

        $Msg .= Debug::Dump($Backtrace);

        if( mail($To,"FRAMEWIRE {$Level}",$Msg,"Reply-To: {$From}\nFrom: {$FromDisplay}",'-f'.$From) !== TRUE )
        {
            $Msg = "Logging error because mail() failed to '$To'.\r\n{$Msg}";
            static::Log($Msg,$Level,$Backtrace,$Context);
        }
    }

    /**
     * Log a message to the browser's console using FirePHP (Wildfire).
     *
     * @param string $Msg The message to log.
     * @param mixed $Msg An array or object to log - non-scalars will be dumped to string.
     * @param string $Level The message severity (LOG, INFO, WARN, ERROR).
     * @param string $Backtrace A string indicating where the message originated.
     * @param array $Backtrace A backtrace array (array of strings).
     * @param array $Context Local variables from the scope in which the message originated.
     */
    public static function Wildfire( $Msg,$Level = 'LOG',$Backtrace = NULL,$Context = NULL )
    {
        static $Rows = array();

        header('X-Wf-Protocol-1: http://meta.wildfirehq.org/Protocol/JsonStream/0.2');
        header('X-Wf-1-Plugin-1: http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/0.3');
        header('X-Wf-1-Structure-1: http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1');

        $Context = $Context['Request'];

        $Meta = array('Type'=>$Level,'Label'=>'FW');
        $Body = array('Msg'=>$Msg,'Context'=>$Context,'Backtrace'=>$Backtrace);

        $T = array($Meta,$Body);
        Struct::ToUTF8($T);
        // see ChromePHP note
        $Rows[] = @json_encode($T);

        foreach( $Rows as $K => $R )
        {
            header('X-Wf-1-1-1-'.($K+1).': '.strlen($R)."|{$R}|");
        }
    }

    /**
     * Log a message to the browser's console using ChromePHP.
     *
     * @param string $Msg The message to log.
     * @param mixed $Msg An array or object to log - non-scalars will be dumped as collapsible objects.
     * @param string $Level The message severity (LOG, INFO, WARN, ERROR).
     * @param string $Backtrace A string indicating where the message originated.
     * @param array $Backtrace A backtrace array (array of strings).
     * @param array $Context Local variables from the scope in which the message originated.
     *
     * @note $Context is killed except for Request.
     */
    public static function ChromePHP( $Msg,$Level = 'LOG',$Backtrace = NULL,$Context = NULL )
    {
        static $H = array('version'=>'3.0.1','columns'=>array('label','log','backtrace','type'),'rows'=>array());

        // context can contain a lot of strange data so we kill it
        $Context = $Context['Request'];
        $H['rows'][] = array("FW",array('Msg'=>$Msg,'Context'=>$Context,'Backtrace'=>$Backtrace),'',strtolower($Level));

        Struct::ToUTF8($H);
        // if json_encode() finds something it doesn't understand (like a variable containing binary image
        // string or a PHP resource) it's error will cause very strange recursion - need to further test with xdebug
        // we could also surpress errors here but for now we're blanking $Context
        $T = json_encode($H);

        // this often requires output_buffering = on since most output will be on it's way before this is called
        header('X-ChromePhp-Data: '.base64_encode(utf8_encode($T)));
    }
}

abstract class Debug
{
    /**
     * Return a backtrace as a smaller, friendlier, array.
     *
     * @param array $Ignores Optional set of function calls to ignore from the backtrace - Backtrace and ErrorHandler
     *                       are always included.
     * @retval array The backtrace array.
     *
     * @todo Determine original call details for originators such as ReMap(), rendering/eval()/__call, Directives.
     */
    public static function Backtrace( $Ignores = array() )
    {
        $BT = array();
        $Ignores = array_merge($Ignores,array('Backtrace','ErrorHandler'));
        foreach( debug_backtrace() as $K => $V )
        {
            $T = array('Class'=>isset($V['class'])?$V['class']:'');

            $T['Function'] = isset($V['function'])?$V['function']:'';
            if( in_array($T['Function'],(array)$Ignores) )
                continue;

            $T['Type'] = isset($V['type'])?$V['type']:'';

            $T['Args'] = isset($V['args'])?$V['args']:array();
            foreach( $T['Args'] as $K2 => &$V2 )
                $V2 = is_object($V2)?get_class($V2).' object':$V2;

            $T['File'] = Struct::Get('file',$V);
            $T['Line'] = Struct::Get('line',$V);
            $T['Basename'] = basename($T['File']);

            $BT[] = $T;
        }

        return $BT;
    }

    /**
     * Convert a backtrace into an array of compact strings.
     *
     * @param array $BT Backtrace array.
     * @param array $FuncFilter Array of functions to include - all others will be skipped.
     * @retval string The bactrace string.
     */
    public static function BT2Str( $BT,$FuncFilter = array() )
    {
        $Buf = array();
        foreach( $BT as $K => $V )
        {
            if( !empty($FuncFilter) )
            {
                if( in_array($V['Function'],(array)$FuncFilter) === FALSE )
                    continue;

                $Buf[] = (strpos($V['Basename'],'eval()\'d')!==FALSE?"eval()({$V['Line']})":"{$V['Basename']}({$V['Line']})");
            }
            else
            {
                $Buf[] = "{$V['Class']}{$V['Type']}{$V['Function']} from "
                        .(strpos($V['Basename'],'eval()\'d')!==FALSE?"eval()({$V['Line']})":"{$V['Basename']}({$V['Line']})");
            }
        }

        return $Buf;
    }

    /**
     * Return a string that's a human-friendly dump of a variable.
     */
    public static function Dump( $Mixed,$Label = NULL )
    {
        if( $Label !== NULL )
            $Buf = "\r\n\r\n---SHOWING LABEL '$Label' OF TYPE ".gettype($Mixed);
        else
            $Buf = "\r\n\r\n---SHOW VARIABLE OF TYPE ".gettype($Mixed);

        ob_start();
        var_dump($Mixed);
        return $Buf."\r\n".ob_get_clean();
    }
}


/**
 * Tools for including files.
 *
 * @note The include_path should be used sparingly, especially in high-traffic applications.
 * @note This class does not protect against security concerns or other mistakes.
 */
abstract class Inc
{
    /**
     * Add a path to the end of the include path.
     *
     * @param string $Path The path to add.
     * @throws Exception \c $Path is not a string.
     * @retval void
     *
     * @note No normalization of \c $Path is done.
     */
    public static function Append( $Path )
    {
        if( is_string($Path) === FALSE )
            throw new Exception('Path is not a string.');

        set_include_path(get_include_path().DIRECTORY_SEPARATOR.$Path);
    }

    /**
     * Add a path to the beginning of the include path.
     *
     * @param string $Path The path to add.
     * @param boolean $OverCWD Set to \c TRUE to add the new path
     * 				  before the current working directory.
     * @throws Exception \c $Path is not a string.
     * @retval void
     */
    public static function Prepend( $Path,$OverCWD = FALSE )
    {
        if( is_string($Path) === FALSE )
            throw new Exception('Path is not a string.');

        $C = get_include_path();

        if( $OverCWD === FALSE && $C[0] === '.' )
            set_include_path('.;'.$Path.substr($C,1));
        else
            set_include_path($Path.';'.$C);
    }

    /**
     * Load an extension that's bundled with Framewire in the /ext/ directory.
     *
     * @param string $ExtLoader The extension's loader file.
     *
     * @note Every extension must have a loader file in FW_ROOT/ext/ which then
     * 	     can load whatever else it needs to.
     * @note This uses require().
     */
    public static function Ext( $ExtLoader )
    {
        require(ASM_ROOT."ext".DIRECTORY_SEPARATOR.$ExtLoader);
    }

    /**
     * Require or perform an operation on a file.
     *
     * If \c $File is a relative path, $Path is prepended.
     *
     * @param string $File The file's path.
     * @param string $Path A path prefix, which by default is APP_ROOT.
     * @param closure|NULL $CB A closure that is executed instead.
     * @retval mixed The return value of the closure, or void.
     *
     * @note If \c $CB is a closure, it is passed the \c $File.
     * @note This uses require().
     * @todo We could have this convert DIR separators automatically to the current platform.
     *        And same with Dir().  Or just have people always use forward slash since Win
     *        doesn't seem to mind, though Linux cares about backslash.
     *
     * @todo Deprecated per new asmblr
     */
/*
    public static function File( $File,$Path = APP_ROOT,$CB = NULL )
    {
        if( Path::IsAbs($File) === FALSE )
            $File = $Path.$File;

        if( is_a($CB,'Closure') === TRUE )
            return $CB($File);
        else
            require($File);
    }
*/
    /**
     * Require or perform an operation recursively on the files in a directory.
     *
     * @param string $Dir The directory's path.
     * @param string $Path The prepended directory prefix if $Dir isn't absolute, which by default is APP_ROOT.
     * @param closure|NULL $CB A closure that is executed on each file instead.
     * @throws Exception \c $Dir is not readable.
     * @retval mixed The return value of the closure, or void.
     *
     * @note If \c $CB is a closure, it is passed the \c $File.
     * @note This uses require().
     * @note This is recursive and the order in which files/directories are read is unknown.
     * @note This skips hidden files (those that start with a period).
     * @note This could do bad things - sanitize your input.
     *
     * @todo Deprecrated per new asmblr
     */
/*
    public static function Dir( $Dir,$Path = APP_ROOT,$CB = NULL )
    {
        if( Path::IsAbs($Dir) === FALSE )
            $Dir = $Path.$Dir;

        if( ($LS = @scandir($Dir)) === FALSE )
            throw new Exception("Dir '$Dir' is not readable.");

        foreach( $LS as $File )
        {
            if( $File{0} === '.' )
                continue;

            $F = $Dir.DIRECTORY_SEPARATOR.$File;

            if( is_dir($F) === TRUE )
            {
                static::Dir($F,$Path,$CB);
            }
            else
            {
                if( is_a($CB,'Closure') === TRUE )
                    $CB($F);
                else
                    require($F);
            }
        }
    }
*/
}


/**
 * Tools for common HTTP 1.1 headers and operations.
 *
 * This includes functions for redirecting, server errors, not found,
 * common content-types, forcing the browser to download a file, and not
 * caching content.
 *
 * @todo Check that these methods are correct when using FastCGI - they seem to be.
 * @todo We may want the option to send HTTP 1.0 headers.
 * @todo We may want the option to send useful cookies in this or another class
 *       (things like remember me, breadcrumbs/user path tracking).
 * @see http://en.wikipedia.org/wiki/Internet_media_type
 * @see http://us2.php.net/manual/en/function.header.php
 */
abstract class HTTP
{
    public static $Types = array(
            'atom'=>'application/atom+xml',
            'rss'=>'application/rss+xml',

            'css'=>'text/css',
            'html'=>'text/html',
            'php'=>'text/x-php',
            'phtml'=>'application/x-httpd-php',

            'js'=>'text/javascript','javascript'=>'text/javascript','json'=>'application/json',
            'js4329'=>'application/javascript','javascript4329'=>'application/javascript',

            'xml'=>'text/xml',

            'text'=>'text/plain',
            'txt'=>'text/plain',
            'vcard'=>'text/vcard',
            'csv'=>'text/csv',

            'eot'=>'application/vnd.ms-fontobject','svg'=>'image/svg+xml',
            'ttf'=>'application/x-font-ttf','woff'=>'application/font-woff',

            'gif'=>'image/gif','jpeg'=>'image/jpeg','jpg'=>'image/jpeg','png'=>'image/png',

            'zip'=>'application/zip','gzip'=>'application/x-gzip','gz'=>'application/x-gzip',

            'mp4'=>'video/mp4','webm'=>'video/webm',

            'pdf'=>'application/pdf',

            'excel'=>'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'xlsx'=>'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'xls'=>'application/vnd.ms-excel',

            'word'=>'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'docx'=>'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'doc'=>'application/msword',

            'powerpoint'=>'application/vnd.openxmlformats-officedocument.presentationml.presentation',
            'pptx'=>'application/vnd.openxmlformats-officedocument.presentationml.presentation',
            'ppt'=>'application/vnd.ms-powerpoint',

            'binary'=>'application/octet-stream',

            'form'=>'application/x-www-form-urlencoded');

    /**
     * Send a 200 OK header.
     */
    public static function _200()
    {
        header('HTTP/1.1 200 OK');
    }

    /**
     * Send a 301 Moved Permanently header.
     */
    public static function _301()
    {
        header('HTTP/1.1 301 Moved Permanently');
    }

    /**
     * Send a 302 Found header.
     */
    public static function _302()
    {
        header('HTTP/1.1 302 Found');
    }

    /**
     * Send a 400 Bad Request header.
     *
     * @param boolean $Exit FALSE to not kill execution after sending the header.
     */
    public static function _400( $Exit = TRUE )
    {
        header('HTTP/1.1 400 Bad Request');
        if( $Exit === TRUE )
            exit;
    }

    /**
     * Send a 401 Unauthorized header.
     *
     * @param boolean $Exit FALSE to not kill execution after sending the header.
     */
    public static function _401( $Exit = TRUE )
    {
        header('HTTP/1.1 401 Unauthorized');
        if( $Exit === TRUE )
            exit;
    }

    /**
     * Send a 403 Forbidden header.
     *
     * @param boolean $Exit FALSE to not kill execution after sending the header.
     */
    public static function _403( $Exit = TRUE )
    {
        header('HTTP/1.1 403 Forbidden');
        if( $Exit === TRUE )
            exit;
    }

    /**
     * Send a 404 Not Found header.
     */
    public static function _404()
    {
        header('HTTP/1.1 404 Not Found');
    }

    /**
     * Send a 500 Internal Server Error header.
     *
     * @param boolean $Exit FALSE to not kill execution after sending the header.
     */
    public static function _500( $Exit = TRUE )
    {
        header('HTTP/1.1 500 Internal Server Error');
        if( $Exit === TRUE )
            exit;
    }

    /**
     * Send a 501 Not Implemented header.
     *
     * @param boolean $Exit FALSE to not kill execution after sending the header.
     */
    public static function _501( $Exit = TRUE )
    {
        header('HTTP/1.1 501 Not Implemented');
        if( $Exit === TRUE )
            exit;
    }

    /**
     * Send a 503 Service Unavailable header.
     *
     * @param boolean $Exit FALSE to not kill execution after sending the header.
     */
    public static function _503( $Exit = TRUE )
    {
        header('HTTP/1.1 503 Service Unavailable');
        if( $Exit === TRUE )
            exit;
    }

    /**
     * Send a Location header for redirecting.
     *
     * @param string $URL The URL to redirect to.
     * @param URL $URL The URL Struct to redirect to.
     * @param boolean $Perm FALSE to not send a 301 header first.
     * @param boolean $Exit FALSE to not kill execution after sending the header.
     */
    public static function Location( $URL,$Perm = TRUE,$Exit = TRUE )
    {
        if( $Perm === TRUE )
            static::_301();

        header('Location: '.(is_array($URL)?URL::ToString($URL):$URL));

        if( $Exit === TRUE )
            exit;
    }

    /**
     * Send no-caching headers.
     */
    public static function NoCache()
    {
        header('Cache-Control: no-cache, must-revalidate');
        header("Expires: Sat, 26 Jul 1997 05:00:00 GMT");
    }

    /**
     * Send caching headers.
     *
     * @param int $Seconds The duration, in seconds, to cache for.
     *
     * @note This is "absolute" caching - the browser won't even request the
     *       resource for the duration specified.
     * @see LastModified() for conditional caching.
     * @see https://developers.google.com/speed/articles/caching
     */
    public static function Cache( $Seconds )
    {
        header('Expires: '.date('r',strtotime("+ $Seconds seconds")));
        header("Cache-Control: max-age={$Seconds}");
        header('Pragma: public');
    }

    /**
     * Send a last modified header.
     *
     * @param string $DateTime A strtotime() compatible string.
     * @param int $DateTime A Unix timestamp.
     * @param NULL $DateTime Default of NULL for current date/time.
     * @retval boolean TRUE if a valid date was determined and the header sent, FALSE if no
     *         header is sent.
     *
     * @note This is conditional caching - browser checks if resource has been modified more
     *       recently than the DateTime specified here.
     * @see Cache() for absolute caching.
     */
    public static function LastModified( $DateTime = NULL )
    {
        if( $DateTime === NULL )
            $DateTime = date('r');
        else if( is_int($DateTime) === TRUE )
            $DateTime = date('r',$DateTime);
        else if( is_string($DateTime) === TRUE )
            $DateTime = @date('r',strtotime($DateTime));
        else
            $DateTime = FALSE;

        if( empty($DateTime) )
            return FALSE;
        else
        {
            header("Last-Modified: $DateTime");
            return TRUE;
        }
    }

    /**
     * Send a Content-Type header.
     *
     * @param string $Type Case insensitive name of a common content-type,
     *                     or if it contains a forward slash it's sent as is.
     * @param string $Charset If not empty, specifies the charset attribute.
     *
     * @todo We should have methods for content-disposition (attachment, download, etc).
     * @todo defaulting the correct content type and charset for html/css/etc should be setable
     *       by some config parameters as defaults.  Akin to attachments, etc.  Perhaps part of Media?
     *       This could all be a part of encoding templates to UTF8 output, headers, etc. as a part
     *       of locale implementation for requests/templates (enUSTemplate ?) and sending international responses.
     * @note Some content-types can be referenced by multiple names, like a common
     *       name and file extension.  If a type isn't recognized, application/octet-stream
     *       is sent.
     * @note $Charset is passed untouched.
     *
     * @see $Types property for available types.
     */
    public static function ContentType( $Type,$Charset = '' )
    {
        header('Content-Type: '.static::ResolveContentType($Type).(empty($Charset)?'':"; charset={$Charset}"));
    }

    /**
     * Resolve a content type to it's proper MIME value, or binary (application/octet-stream)
     * if it can't be resolved.
     *
     * @param string $Type Case insensitive name of a common content-type,
     *                     or if it contains a forward slash it's sent as is.
     * @param bool $Strict Return NULL if the type can't be determined.
     */
    public static function ResolveContentType( $Type,$Strict = FALSE )
    {
        if( strpos($Type,'/') !== FALSE )
        {
            return strtolower($Type);
        }
        else
        {
            $Type = strtolower($Type);
            return (isset(static::$Types[$Type])===TRUE?static::$Types[$Type]:($Strict===TRUE?NULL:static::$Types['binary']));
        }
    }

    /**
     * Return the short-names of the known content types.
     *
     * @param bool $Full TRUE to return full content types.
     * @retval array An array of known content types.
     */
    public static function GetContentTypes( $Full = FALSE )
    {
        if( $Full === TRUE )
            return static::$Types;
        else
            return array_keys(static::$Types);
    }

    /**
     * Try to determine the content type from a filename's extension.
     *
     * @param string $Filename The filename to resolve.
     * @retval string The content type.
     * @retval NULL The content type could not be determined.
     */
    public static function Filename2ContentType( $Filename )
    {
        $Ext = pathinfo($Filename);
        $Ext = strtolower(Struct::Get('extension',$Ext));

        return isset(static::$Types[$Ext])===TRUE?static::$Types[$Ext]:NULL;
    }

    /**
     * Send the headers to force a file download/save-as.
     *
     * This doesn't actually send the file.
     *
     * @param string $Filename The filename to save-as.
     * @param string $Type The content-type name.
     * @param string $Length The content-length, if known.
     *
     * @see ContentType()
     * @todo No crazy encoding of filename is done - suggestions welcome.
     * @todo No content-transfer-encoding is supported currently.
     * @note Setting a content length causes IIS to reset the connection for some reason
     *       (probably internal buffering or something since it appears to add it's own value).
     */
    public static function SaveAs( $Filename,$Type = NULL,$Length = NULL )
    {
        static::ContentType($Type);
        header("Content-Disposition: attachment; filename=\"{$Filename}\"");
        header('Cache-Control: must-revalidate');
        header('Pragma: ');

        if( $Length !== NULL )
            header("Content-Length: $Length}");
    }
}


/**
 * A Struct manages arrays that have an overall consistent structure.
 *
 * Struct supports both associative and integer indexed arrays, or even a mixed
 * array.  However, mixing the two in a single array is not recommended, and can cause
 * unpredictable results.
 *
 * For the methods with a RefPoint parameter, these rules are used:
 *
 *  - When RefPoint is an integer, working with an integer array is assumed and keys are not maintained.
 *  - When RefPoint is a string, working with an associative array is assumed and keys are maintained.
 *
 * All methods that insert a new Element will attempt to insert it as a whole - only one
 * new element will be created.
 *
 * @see Is for methods that operate on elements of generic arrays.
 *
 * By convention, the general structure of a Struct managed array is defined in the
 * $Skel property.  A new Struct array is created by an Init() method and returned.
 *
 * A general way to think of Structs is as the minimal amount of elements and their
 * expected values/types that are needed for a purpose.  The array may contain more
 * elements.
 */
abstract class Struct
{
    /**
     * Baseline default structure for a Struct.
     */
    protected static $Skel = array();


    /**
     * Determine whether the array has a known structure.
     *
     * This compares the keys of $Arr to that of Struct::$Skel.
     *
     * If a more complete comparision, including type checking, is needed,
     * see Is::Equal().
     *
     * @param array $Path The array to check.
     * @return boolean TRUE if the keys are known.
     */
    public static function IsA( $Path )
    {
        return (array_keys($Path) === array_keys(static::$Skel));
    }


    /**
     * Append a new element to the array.
     *
     * @param mixed $Element Element to append.
     * @param array $Subject The array to append to.
     * @throws Exception Element with key already exists.
     * @throws Exception Invalid Element.
     * @retval int The position, counting from 0, at which the element was appended.
     */
    public static function Append( $Element,&$Subject )
    {
        if( is_array($Element) === FALSE )
        {
            $Subject[] = $Element;
            return count($Subject)-1;
        }
        else if( count($Element) === 1 )
        {
            if( isset($Subject[key($Element)]) === FALSE || is_int(key($Element)) === TRUE )
            {
                $Subject = array_merge($Subject,$Element);
                return count($Subject)-1;
            }
            else
                throw new Exception('Element with key '.key($Element).' already exists.');
        }
        else
            throw new Exception('Invalid Element.');
    }

    /**
     * Prepend a new element to the array.
     *
     * @param mixed $Element Element to prepend.
     * @param array $Subject The array to prepend to.
     * @throws Exception Element with key already exists.
     * @throws Exception Invalid Element.
     * @retval int 0
     */
    public static function Prepend( $Element,&$Subject )
    {
        if( is_array($Element) === FALSE )
        {
            array_splice($Subject,0,0,$Element);
            return 0;
        }
        else if( count($Element) === 1 )
        {
            if( isset($Subject[key($Element)]) === FALSE || is_int(key($Element)) === TRUE )
            {
                //array_splice($Subject,0,0,$Element);
                $Subject = array_merge($Element,$Subject);
                return 0;
            }
            else
                throw new Exception('Element with key '.key($Element).' already exists.');
        }
        else
            throw new Exception('Invalid Element.');
    }

    /**
     * Insert a new element before another element.
     *
     * Element is inserted as a whole, regardless of it's keys, if any.
     *
     * @param mixed $Element Element to insert.
     * @param int|string $RefPoint Reference point of insertion as either an associative or numeric key.
     * @param array &$Subject The array to insert into.
     * @throws Exception Element with key already exists.
     * @throws Exception Invalid RefPoint or Element.
     * @retval int The position, counting from 0, at which insertion occurred.
     * @retval NULL RefPoint was not found and nothing was inserted.
     */
    public static function InsertBefore( $Element,$RefPoint,&$Subject )
    {
        if( is_int($RefPoint) === TRUE )
        {
            if( isset($Subject[$RefPoint]) === TRUE )
            {
                array_splice($Subject,$RefPoint,0,is_array($Element)===TRUE?array($Element):$Element);
                return $RefPoint;
            }
            else
                return NULL;
        }
        else if( is_string($RefPoint) === TRUE && is_array($Element) === TRUE )
            // && count($Element) === 1
        {
            if( isset($Subject[key($Element)]) === FALSE )
            {
                if( ($RefPoint = static::KeyPosition($RefPoint,$Subject)) === NULL )
                    return NULL;
                $Subject = array_merge(array_splice($Subject,0,$RefPoint),$Element,$Subject);
                return $RefPoint;
            }
            else
                throw new Exception('Element with key '.key($Element).' already exists.');
        }
        else
            throw new Exception('Invalid RefPoint or Element.');
    }

    /**
     * Insert a new element after another element.
     *
     * Element is inserted as a whole, regardless of it's keys, if any.  If it's an array, it can
     * have only a single key/value pair (unlike InsertBefore).
     *
     * @param mixed $Element Element to insert.
     * @param int|string $RefPoint Reference point of insertion as either an associative or numeric key.
     * @param array &$Subject The array to insert into.
     * @throws Exception Element with key already exists.
     * @throws Exception Invalid RefPoint or Element.
     * @retval int The position, counting from 0, at which insertion occurred.
     * @retval NULL RefPoint was not found and nothing was inserted.
     */
    public static function InsertAfter( $Element,$RefPoint,&$Subject )
    {
        if( is_int($RefPoint) === TRUE )
        {
            if( isset($Subject[$RefPoint]) === TRUE )
            {
                array_splice($Subject,++$RefPoint,0,is_array($Element)===TRUE?array($Element):$Element);
                return $RefPoint;
            }
            else
                return NULL;
        }
        else if( is_string($RefPoint) === TRUE && is_array($Element) === TRUE && count($Element) === 1 )
        {
            if( isset($Subject[key($Element)]) === FALSE )
            {
                if( ($RefPoint = static::KeyPosition($RefPoint,$Subject)) === NULL )
                    return NULL;
                $Subject = array_merge(array_splice($Subject,0,++$RefPoint),$Element,$Subject);
                return $RefPoint;
            }
            else
                throw new Exception('Element with key '.key($Element).' already exists.');
        }
        else
            throw new Exception('Invalid RefPoint or Element.');
    }

    /**
     * Remove an element from an array.
     *
     * If $Needle is an integer, the remaining keys will be reindexed.  In an associative,
     * $Needle indicates the position of the element to remove, not it's actual key.
     *
     * @param int|string $Needle Key of the element to remove.
     * @param array &$Haystack The array to remove the element from.
     * @retval boolean TRUE if $Needle was found and it's element removed.
     */
    public static function Del( $Needle,&$Haystack )
    {
        if( isset($Haystack[$Needle]) === TRUE )
        {
            if( is_int($Needle) === TRUE )
                array_splice($Haystack,$Needle,1);
            else
                unset($Haystack[$Needle]);

            return TRUE;
        }
        else
            return FALSE;
    }

    /**
     * Read or check the value of an element.
     *
     * If $Check is provided, strict type checking is used.
     *
     * @param int|string $Needle Key of the element to read.
     * @param array $Haystack The array to read the element from.
     * @param mixed $Check Optional value to check the element's value against.
     * @retval mixed The element's value if no $Check was provided.
     * @retval NULL $Needle was not found and no $Check was provided.
     * @retval boolean TRUE if $Check was provided and the values matched.
     */
    public static function Get( $Needle,$Haystack,$Check = NULL )
    {
        if( isset($Haystack[$Needle]) === TRUE )
            return ($Check===NULL)?$Haystack[$Needle]:($Haystack[$Needle]===$Check);
        else
            return NULL;
    }

    /**
     * Convert the values of an array into a string.
     *
     * @param array $Subject The array to convert.
     * @param string $Surround A string to surround each value with.
     * @param string $Delim A string to seperate each value.
     * @retval string The array values as a string.
     * @retval NULL \c Subject was not an array.
     *
     * @note If \c $Surround is a single character and appears in a value, it is
     * 		 escaped with a backslash.
     */
    public static function Dissolve( $Subject,$Surround = '\'',$Delim = ',' )
    {
        if( is_array($Subject) === TRUE )
            return $Surround.implode($Surround.$Delim.$Surround,
                                    (strlen($Surround)===1?str_replace($Surround,"\\$Surround",$Subject):$Surround)).$Surround;
        else
            return NULL;
    }

    /**
     * Get a column of values from a Is::Columnar() array.
     *
     * @param string $Needle The name of the column to get.
     * @param array $Haystack A columnar array.
     * @retval array The column's values.
     * @retval NULL The array isn't columnar.
     *
     * @note If some "rows" don't have the column specified, the NULL value will be filled in.
     */
    public static function GetColumn( $Needle,$Haystack )
    {
        if( Is::Columnar($Haystack) === TRUE )
        {
            $Column = array();
            foreach( $Haystack as $V )
                $Column[] = (isset($V[$Needle])===TRUE?$V[$Needle]:NULL);
            return $Column;
        }
        else
            return NULL;
    }

    /**
     * Create an array from a base array with certain elements masked out by key.
     *
     * @param array $Mask A numeric array of keys to mask.
     * @param array $Haystack The base array.
     * @retval array The new array.
     */
    public static function KeyMask( $Mask,$Haystack )
    {
        return array_diff_key($Haystack,array_fill_keys($Mask,TRUE));
    }

    /**
     * Determine the absolute position of a key in an array.
     *
     * This method will consistently return the numeric position of an array's key, even if
     * the array is associative or non-consecutive.
     *
     * The search is done using strict type checking.
     *
     * @param string $Needle The key to search for.
     * @param array $Haystack The array to search.
     * @retval int The position of $Needle.
     * @retval NULL $Needle was not found.
     */
    public static function KeyPosition( $Needle,$Haystack )
    {
        return ($P = array_search($Needle,array_keys($Haystack),TRUE))===FALSE?NULL:$P;
    }

    /**
     * Convert a string, or recursively convert an array, to UTF-8.
     *
     * @param array $A A reference to the array to convert.
     * @param string $A A reference to the string to convert.
     *
     * @todo Review where else this might be used, if it should be
     *       moved (to Struct?), and if it's correct.
     */
    public static function ToUTF8( &$A )
    {
        if( is_array($A) === TRUE )
        {
            foreach( $A as &$V )
            {
                // Avoid encoding already encoded UTF-8 - TRUE is required to make a strict test.
                if( is_string($V) === TRUE && mb_detect_encoding($V,'UTF-8, ISO-8859-1',TRUE) !== 'UTF-8')
                    $V = mb_convert_encoding($V,'UTF-8');
                else if( is_array($V) === TRUE )
                    static::ToUTF8($V);
            }
        }
        else if( is_string($A) === TRUE )
        {
            if( mb_detect_encoding($A,'UTF-8, ISO-8859-1',TRUE) !== 'UTF-8')
                $A = mb_convert_encoding($A,'UTF-8');
        }
    }
}


/**
 * Check elements of any array.
 *
 * @todo Clean-up and test, especially Equal().
 */
abstract class Is
{
    /**
     * Determine whether two arrays have the same structure.
     *
     * Two arrays have the same structure when:
     *  - elements occur in the same order and have the same keys.
     *  - the values of each element are of the same type (using What()).
     *
     * The values of each element are not compared - only their types are.
     *
     * @param array $Subject1 The first array to compare.
     * @param array $Subject2 The second array to compare.
     * @param boolean $Recurse \c TRUE to recursively compare arrays.
     * @param array $Ignore An array of elements to ignore.
     * @throws Exception \c Subject1 is not an array.
     * @throws Exception \c Subject2 is not an array.
     * @retval boolean \c TRUE if the arrays have the same structure.
     *
     * @note All comparisions are type strict (===).
     * @todo This is recursive - actually, that's probably broken, as is Ignore
     * @todo Skip the value check (i.e., always TRUE) if the type is NULL.
     * @todo This is used a lot - mostly via IsA() - and should be profiled.
     */
    public static function Equal( $Subject1,$Subject2,$Recurse = FALSE,$Ignore = array() )
    {
        if( is_array($Subject1) === FALSE )
            throw new Exception('Subject1 is not an array.');
        else if( is_array($Subject2) === FALSE )
            throw new Exception('Subject2 is not an array.');

        $S1 = static::KeyMask($Ignore,$Subject1);
        $S2 = static::KeyMask($Ignore,$Subject2);

        if( array_keys($S1) === array_keys($S2) )
        {
            foreach( $S1 as $K => $V )
            {
                if( ($Recurse === TRUE) && (is_array($S1[$K]) === TRUE && is_array($S2[$K]) === TRUE) )
                {
                    if( static::IsEqual($S1[$K],$S2[$K],$Ignore) === FALSE )
                        return FALSE;
                }
                else if( (static::What($K,$S1) !== static::What($K,$S2)) )
                {
                    return FALSE;
                }
            }

            return TRUE;
        }
        else
            return FALSE;
    }

    /**
     * Determine the type of a variable or a value in an array.
     *
     * Uses PHP's \c is_* functions to make the determination and returns
     * the name of the function after the \c is_* part.  Thus, the returned
     * string is one of:
     *
     * 	\li \c string
     *  \li \c int
     *  \li \c bool
     *  \li \c array
     *  \li \c object
     *  \li \c null
     *  \li \c float
     *
     * @param mixed $Needle The value to check or the key of an array to check.
     * @param array $Haystack The array to search, or \c NULL.
     * @retval string The name of the type.
     * @retval NULL The value's type isn't known.
     * @retval FALSE The \c Needle wasn't found in \c Haystack.
     *
     * @todo Possibly handle \c is_numeric() vs \c is_int().
     * @todo Possibly handle \c is_scalar().
     */
    public static function What( $Needle,$Haystack = NULL )
    {
        if( is_array($Haystack) === TRUE )
        {
            if( array_key_exists($Needle,$Haystack) === TRUE )
                $Needle = $Haystack[$Needle];
            else
                return FALSE;
        }

        if( is_string($Needle) === TRUE )
            return 'string';
        else if( is_int($Needle) === TRUE )
            return 'int';
        else if( is_bool($Needle) === TRUE )
            return 'bool';
        else if( is_array($Needle) === TRUE )
            return 'array';
        else if( is_object($Needle) === TRUE )
            return 'object';
        else if( is_null($Needle) === TRUE )
            return 'null';
        else if( is_float($Needle) === TRUE )
            return 'float';
        else
            return NULL;
    }

    /**
     * Return \c TRUE if \c Needle exists in \c Haystack and is a string.
     */
    public static function String( $Needle,$Haystack )
    {
        return (isset($Haystack[$Needle]) === TRUE && is_string($Haystack[$Needle]) === TRUE);
    }

    /**
     * Return \c TRUE if \c Needle exists in \c Haystack and is an integer.
     *
     * @note This method returns \c TRUE for both strings and integers.
     * @note \c IsFloat/\c IsNumeric are not currently implemented.
     */
    public static function Int( $Needle,$Haystack )
    {
        return (isset($Haystack[$Needle]) === TRUE && (ctype_digit($Haystack[$Needle]) === TRUE || is_int($Haystack[$Needle]) === TRUE) );
    }

    /**
     * Return \c TRUE if \c Needle exists in \c Haystack and is a boolean.
     */
    public static function Bool( $Needle,$Haystack )
    {
        return (isset($Haystack[$Needle]) === TRUE && is_boolean($Haystack[$Needle]) === TRUE);
    }

    /**
     * Return \c TRUE if \c Needle exists in \c Haystack and is boolean \c TRUE.
     *
     * @todo Rename?
     */
    public static function TRUE( $Needle,$Haystack )
    {
        return (isset($Haystack[$Needle]) === TRUE && $Haystack[$Needle] === TRUE);
    }

    /**
     * Return \c TRUE if \c Needle exists in \c Haystack and is boolean \c FALSE.
     *
     * @todo Rename?
     */
    public static function FALSE( $Needle,$Haystack )
    {
        return (isset($Haystack[$Needle]) === TRUE && $Haystack[$Needle] === FALSE);
    }

    /**
     * Return \c TRUE if \c Needle exists in \c Haystack and is an array.
     */
    public static function Arr( $Needle,$Haystack )
    {
        return (isset($Haystack[$Needle]) === TRUE && is_array($Haystack[$Needle]) === TRUE);
    }

    /**
     * Return \c TRUE if \c Needle exists in \c Haystack and is an object.
     */
    public static function Object( $Needle,$Haystack )
    {
        return (isset($Haystack[$Needle]) === TRUE && is_object($Haystack[$Needle]) === TRUE);
    }

    /**
     * Return \c TRUE if \c Needle exists in \c Haystack and is a \c NULL value.
     *
     * @todo Rename?
     */
    public static function NULL( $Needle,$Haystack )
    {
        return (is_array($Haystack) === TRUE && array_key_exists($Needle,$Haystack) === TRUE && $Haystack[$Needle] === NULL);
    }

    /**
     * Determine if all keys of an array are integers.
     *
     * @param array $Haystack The array to check.
     * @retval boolean TRUE if the array is numericly indexed.
     * @retval NULL Haystack is not an array.
     *
     * @note This does not check whether the keys are in sequential order.
     */
    public static function Numeric( $Haystack )
    {
        if( is_array($Haystack) === TRUE )
        {
            foreach( $Haystack as $K => $V )
                if( is_int($K) === FALSE )
                    return FALSE;

            return TRUE;
        }
        else
            return NULL;
    }

    /**
     * Determine if all keys of an array are strings.
     *
     * @param array $Haystack The array to check.
     * @retval boolean TRUE if the array is associativly indexed.
     * @retval NULL Haystack is not an array.
     */
    public static function Assoc( $Haystack )
    {
        if( is_array($Haystack) === TRUE )
        {
            foreach( $Haystack as $K => $V )
                if( is_string($K) === FALSE )
                    return FALSE;

            return TRUE;
        }
        else
            return NULL;
    }

    /**
     * Determine if the array is an numerically indexed array of other arrays (columns).
     *
     * @param array $Haystack The array to check.
     * @retval boolean \c TRUE if the array is columnar.
     * @retval NULL \c Haystack is not an array.
     *
     * @todo This needs to be tested.
     */
    public static function Columnar( $Haystack )
    {
        if( is_array($Haystack) === TRUE )
        {
            foreach( $Haystack as $Key => $Column )
            {
                if( is_int($Key) === FALSE || is_array($Column) === FALSE )
                    return FALSE;
            }

            return TRUE;
        }
        else
            return NULL;
    }

    /**
     * Check if certain keys exist in an array.
     *
     * @param scalar $Needles A single key to check for.
     * @param array $Needles An array of keys (as values) to check for.
     * @param array $Haystack The array to check.
     * @retval boolean TRUE if all keys are present.
     *
     * @note array_key_exists() is used, thus the check is case-sensitive, loosely typed, and will
     *       return TRUE if the element exists but is set to NULL.
     */
    public static function Keys( $Needles,$Haystack )
    {
        foreach( ((array) $Needles) as $N )
        {
            if( array_key_exists($N,$Haystack) === FALSE )
                return FALSE;
        }

        return TRUE;
    }

    /**
     * Check if certain values exist in an array.
     *
     * @param scalar $Needles A single value to check for.
     * @param array $Needles An array of values to check for.
     * @param array $Haystack The array to check.
     * @retval boolean TRUE if all values are present.
     *
     * @note Type-strict checking is performed using in_array().
     */
    public static function Values( $Needles,$Haystack )
    {
        foreach( ((array) $Needles) as $N )
        {
            if( in_array($N,$Haystack,TRUE) === FALSE )
                return FALSE;
        }

        return TRUE;
    }
}


/**
 * Tools for managing a path.
 *
 * By default, a Path uses the forward slash (\c /) as a separator.
 *
 * The structure of a Path Struct is:
 *
 *  \li Separator: the path's separator.
 *  \li IsAbs: \c TRUE if the path has a leading separator.
 *  \li IsDir: \c TRUE if the path has a trailing separator.
 *  \li IsRoot: \c if the path is only the separator (IsDir and IsAbs will also be TRUE).
 *  \li Segments: numeric array of the pieces between the separators.
 *
 * A path segment is what's contained between two separators, or a separator
 * and the end of the string.
 *
 * @note No automatic encoding/decoding/escaping is done.
 * @note This is platform agnostic - it doesn't know if it's running under Windows or Unix.
 * @note This currently does not watch for insecure paths, like /../../
 */
abstract class Path extends Struct
{
    protected static $Skel = array('Separator'=>'/','IsAbs'=>TRUE,'IsDir'=>TRUE,
    							   'IsRoot'=>TRUE,'Segments'=>array());

    /**
     * Create a Path from a string.
     *
     * The separator is set as a back slash if one is found.
     *
     * @param string $PathStr The path string to parse, an empty string, or NULL.
     * @param string $Separator Specify a single character as a separator to use.
     * @retval array The Path.
     *
     * @note An empty or NULL $PathStr, or one that is simply multiple Separators,
     * 		 will be considered a root path.  A non-string is cast.
     */
    public static function Init( $PathStr,$Separator = NULL )
    {
        $P = static::$Skel;

        if( empty($Separator) )
        {
            if( strpos($PathStr,'\\') !== FALSE )
                $P['Separator'] = '\\';
        }
        else
            $P['Separator'] = $Separator;

        $PathStr = trim($PathStr);

        // a root path
        if( empty($PathStr) || $PathStr === $P['Separator'] || trim($PathStr,$P['Separator']) === '' )
        {
            $P['Segments'][0] = $P['Separator'];
        }
        else
        {
            $P['IsRoot'] = FALSE;
            $P['IsAbs'] = $PathStr[0]===$P['Separator']?TRUE:FALSE;
            $P['IsDir'] = substr($PathStr,-1,1)===$P['Separator']?TRUE:FALSE;
            $P['Segments'] = preg_split("(\\{$P['Separator']}+)",$PathStr,-1,PREG_SPLIT_NO_EMPTY);
        }

        return $P;
    }

    /**
     * Create a string from the Path array.
     *
     * @param array $Path A Path Struct.
     * @param URL $EncodeType Properly encode each segment as a URL.
     * @param Shell $EncodeType Properly encode each segment as a shell command.
     * @param NULl $EncodeType Don't perform any encoding.
     * @throws Exception Unknown EncodeType.
     * @retval string The path string.
     *
     * @todo Make this faster.
     */
    public static function ToString( $Path,$EncodeType = NULL )
    {
        if( $Path['IsRoot'] === TRUE )
        {
            return $Path['Separator'];
        }
        else
        {
            $Segs = '';
            if( $EncodeType === 'URL' )
            {
                foreach( $Path['Segments'] as $K => $V )
                    $Segs .= ($K>0?$Path['Separator']:'').rawurlencode($V);
            }
            else if( $EncodeType === 'Shell' )
            {
                foreach( $Path['Segments'] as $K => $V )
                    $Segs .= ($K>0?$Path['Separator']:'').escapeshellcmd($V);
            }
            else if( $EncodeType === NULL )
                $Segs = implode($Path['Separator'],$Path['Segments']);
            else
                throw new Exception("Unknown EncodeType '$EncodeType'.");

            return ($Path['IsAbs']===TRUE?$Path['Separator']:'').$Segs.($Path['IsDir']===TRUE?$Path['Separator']:'');
        }
    }

    /**
     * Create a URL encoded string from the Path.
     *
     * @param array $Path A Path Struct.
     * @retval string The path string.
     */
    public static function ToURLString( $Path )
    {
        return static::ToString($Path,'URL');
    }

    /**
     * Create a shell encoded string from the Path.
     *
     * @param array $Path A Path Struct.
     * @retval string The path string.
     */
    public static function ToShellString( $Path )
    {
        return static::ToString($Path,'Shell');
    }

    /**
     * Make all Segments of a Path Struct lowercase.
     *
     * @param array $Path A reference to the Path.
     * @retval void
     */
    public static function Lower( &$Path )
    {
        foreach( $Path['Segments'] as &$V )
            $V = strtolower($V);
    }

    /**
     * Merge $Src segments into $Dest segments.
     *
     * If $Src has the same segment at the same position as $Dest, it is
     * skipped.  Otherwise, $Src segments are appended to $Dest.
     *
     * @param array $Src The Path to merge in.
     * @param array $Dest A reference to the base Path to merge into.
     * @retval void
     *
     * @note All comparisions are type strict (===).
     * @note This is a no-op if $Src IsRoot is TRUE.
     * @note $Dest will have same IsDir as $Src.
     * @note $Dest will become IsRoot FALSE.
     */
    public static function Merge( $Src,&$Dest )
    {
        if( $Src['IsRoot'] === TRUE )
            return;

        if( $Dest['IsRoot'] === TRUE )
            $Dest['Segments'] = array();

        $Dest['IsDir'] = $Src['IsDir'];
        $Dest['IsRoot'] = FALSE;

        foreach( $Src['Segments'] as $K => $V )
        {
            if( isset($Dest['Segments'][$K]) === TRUE && $Dest['Segments'][$K] === $V )
                continue;
            else
                $Dest['Segments'][] = $V;
        }
    }

    /**
     * Remove matching segments that exist in $Mask from $Base.
     *
     * If $Mask contains the same segments in the same positions as $Base,
     * remove those matching segments from $Base.
     *
     * @param array $Mask The Path that masks segments.
     * @param array $Base The Path that will have segments removed.
     * @retval void
     *
     * @note This is implemented using array_diff() and array_values().
     * @note This is a no-op if either $Mask or $Base is IsRoot TRUE.
     * @note This may cause $Base to become IsRoot and IsDir TRUE.
     */
    public static function Mask( $Mask,&$Base )
    {
        if( $Mask['IsRoot'] === TRUE || $Base['IsRoot'] === TRUE )
            return;

        $Base['Segments'] = array_values(array_diff_assoc($Base['Segments'],$Mask['Segments']));
        if( empty($Base['Segments']) )
        {
            $Base['Segments'][0] = $Base['Separator'];
            $Base['IsDir'] = $Base['IsRoot'] = TRUE;
        }
    }

    /**
     * Determine if a string appears to be an absolute path.
     *
     * A string is considered an absolute path under the following conditions:
     *
     *  \li The first character is a forward slash or a backslash.
     *  \li The second character is a colon (for Windows paths).
     *
     * @param string $Path The string to check.
     * @throws Exception $Path is not a string.
     * @retval boolean TRUE if the string is an absolute path.
     */
    public static function IsAbs( $Path )
    {
        if( is_string($Path) === FALSE )
            throw new Exception("Path is not a string.");

        return ((strpos($Path,'/')===0) || (strpos($Path,'\\')===0) || (strpos($Path,':')===1));
    }

    /**
     * Return TRUE if $Child is a child of $Parent.
     *
     * @param array $Child The child path.
     * @param array $Parent The parent path.
     * @retval boolean TRUE if $Child is a child of $Parent.
     *
     * @note If both $Child and $Parent IsRoot is TRUE, this returns FALSE.
     *       If $Child IsRoot is TRUE this  returns FALSE.
     *       If $Parent IsRoot is TRUE this returns TRUE.
     */
    public static function IsChild( $Child,$Parent )
    {
        if( ($Child['IsRoot'] === TRUE && $Parent['IsRoot'] === TRUE) || ($Child['IsRoot'] === TRUE) )
            return FALSE;
        else if( $Parent['IsRoot'] === TRUE )
            return TRUE;

        return (count(array_intersect_assoc($Child['Segments'],$Parent['Segments'])) === count($Parent['Segments']));
    }

    /**
     * Override base Struct methods to work on segments.
     *
     * $Element must be a string.
     */
    public static function Append( $Element,&$Subject )
    {
        if( empty($Subject['Separator']) )
            debug_print_backtrace();

        $Element = trim($Element);
        if( substr($Element,-1,1) === $Subject['Separator'] )
            $Subject['IsDir'] = TRUE;
        else
            $Subject['IsDir'] = FALSE;

        $Element = trim($Element,$Subject['Separator']);
        if( empty($Element) )
            return NULL;

        $Subject['Segments'] = $Subject['IsRoot']===TRUE?array():$Subject['Segments'];

        return parent::Append($Element,$Subject['Segments']);
    }

    public static function Prepend( $Element,&$Subject )
    {
        $Element = trim($Element);
        // TODO: is this needed?  should we assume that the common case
        // is to not change whether the path is absolute
        if( substr($Element,0,1) === $Subject['Separator'] )
            $Subject['IsAbs'] = TRUE;

        $Element = trim($Element,$Subject['Separator']);
        if( empty($Element) )
            return NULL;

        $Subject['Segments'] = $Subject['IsRoot']===TRUE?array():$Subject['Segments'];

        return parent::Prepend($Element,$Subject['Segments']);
    }

    public static function InsertAfter( $Element,$RefPoint,&$Subject )
    {
        if( ($Posi = array_search($RefPoint,$Subject['Segments'])) !== FALSE )
        {
            $Element = trim($Element);
            if( $Posi === (count($Subject['Segments'])-1) && substr($Element,-1,1) === $Subject['Separator'] )
                $Subject['IsDir'] = TRUE;

            $Element = trim($Element,$Subject['Separator']);
            if( empty($Element) )
                return;

            $Subject['Segments'] = $Subject['IsRoot']===TRUE?array():$Subject['Segments'];

            return parent::InsertAfter($Element,$RefPoint,$Subject['Segments']);
        }
        else
            return NULL;
    }

    public static function InsertBefore( $Element,$RefPoint,&$Subject )
    {
        if( ($Posi = array_search($RefPoint,$Subject['Segments'])) !== FALSE )
        {
            $Element = trim($Element);
            if( $Posi === 0 && substr($Element,0,1) === $Subject['Separator'] )
                $Subject['IsAbs'] = TRUE;

            $Element = trim($Element,$Subject['Separator']);
            if( empty($Element) )
                return;

            $Subject['Segments'] = $Subject['IsRoot']===TRUE?array():$Subject['Segments'];

            return parent::InsertBefore($Element,$RefPoint,$Subject['Segments']);
        }
        else
            return NULL;
    }

    /**
     * See note for bottom - it may be appropriate to put ability to fetch
     * last, second-last, etc (perhaps modeled after substr().
     *
     * Right now it's a quick hack to mean a negative Needle to count in from the end.
     * No type of "length" is available (only one segment is returned).
     *
     * @param unknown_type $Needle
     * @param unknown_type $Haystack
     * @param unknown_type $Check
     */
    public static function Get( $Needle,$Haystack,$Check = NULL )
    {
        if( $Needle < 0 )
            return parent::Get(count($Haystack['Segments'])+$Needle,$Haystack['Segments'],$Check);
        else
            return parent::Get($Needle,$Haystack['Segments'],$Check);
    }

    /**
     * Prepend or append a segment in a Path.
     *
     * $Needle is a string defining the change to make:
     *  - \c <segment: prepend the segment.
     *  - \c >segment: append the segment.
     *
     * @param string $Needle Direction and segment to add.
     * @param array $Haystack Path Struct.
     * @retval int The position the segment was added.
     * @retval NULL Operation not recognized.
     *
     * @todo This may be expanded slightly.
     */
    public static function Set( $Needle,&$Haystack )
    {
        $Needle = trim($Needle);

        if( $Haystack['IsRoot'] === TRUE )
        {
            $Haystack['IsRoot'] = FALSE;
            $Haystack['Segments'][0] = ltrim(ltrim($Needle,'<'),'>');
            return count($Haystack['Segments']);
        }

        if( $Needle[0] === '<' )
            return static::Prepend(ltrim($Needle,'<'),$Haystack);
        else if( $Needle[0] === '>' )
            return static::Append(ltrim($Needle,'>'),$Haystack);
        else
            return NULL;
    }

    /**
     * Delete a segment by position.
     *
     * @param int $Needle The position of the segment, counting from 0.
     * @param array $Haystack Path Struct.
     */
    public static function Del( $Needle,&$Haystack )
    {
        return parent::Del($Needle,$Haystack['Segments']);
    }

    /**
     * Read one or more path segments from the top.
     *
     * In a path such as /one/two/three, "one" is the top most segment.
     *
     * @param array $Haystack Path Struct.
     * @param int $Limit Optional number of segments to read, starting from 1.
     * @retval string The single top-most path segment.
     * @retval array The specified number of top-most path segments as a new Path Struct.
     */
    public static function Top( $Haystack,$Limit = 0 )
    {
        if( $Limit > 0 )
        {
            $H2 = $Haystack;
            $H2['Segments'] = array_slice($Haystack['Segments'],0,$Limit);
            return $H2;
        }
        else
            return $Haystack['Segments'][0];
    }

    /**
     * Read one or more path segments from the bottom.
     *
     * In a path such as /one/two/three, "three" is the bottom most segment.
     *
     * @param array $Haystack Path Struct.
     * @param int $Limit Optional number of segments to read, starting from 1.
     * @retval string The single bottom-most path segment.
     * @retval array The specified number of bottom-most path segments as a new Path Struct.
     */
    public static function Bottom( $Haystack,$Limit = 0 )
    {
        if( $Limit > 0 )
        {
            $H2 = $Haystack;
            $H2['Segments'] = array_slice($Haystack['Segments'],count($Haystack['Segments'])-$Limit);
            return $H2;
        }
        else
            return $Haystack['Segments'][count($Haystack['Segments'])-1];
    }

    /**
     * Iterate through a \c Path segment by segment, left to right or right to left.
     *
     * This creates an array containing increasingly more or less specific versions of
     * the same path.
     *
     * @param string $Path The Path Struct.
     * @param boolean $Inc Iterate in increasing path size, i.e., most general to most specific.
     * @retval array Ordered path segments.
     *
     * @note This doesn't honor IsDir or IsAbs of the Path struct - there will always be leading
     *       and trailing separators on all segments.
     */
    public static function Order( $Path,$Inc = TRUE )
    {
        if( Path::IsA($Path) === FALSE )
            throw new Exception('Path is not a Path Struct');

        if( $Path['IsRoot'] === TRUE )
            return array($Path['Separator']);

        $P = array();
//        $Len = count($Path['Segments'])-1;
        foreach( $Path['Segments'] as $K => $V )
            $P[] = ($K>0?$P[$K-1]:(($Path['Separator']))).$V.$Path['Separator'];

//        if( $Path['IsDir'] === TRUE )
//            $P[$Len] .= $Path['Separator'];

        if( $Inc === TRUE )
            return $P;
        else
            return array_reverse($P);
    }
}


/**
 * Tools for manipulating a hostname.
 *
 * The structure of a Hostname Struct is 0 through N subdomain parts,
 * counting from the TLD.
 *
 * For example www.framewire.org would be represented as:
 *
 *  - \c 0:  \c org
 *  - \c 1:  \c framewire
 *  - \c 2:  \c www
 *
 * The \c Hostname::Bottom() method would return \c org and \c Hostname::Bottom()
 * would return \c www.
 *
 * This does not currently support IDNA, nor check for invalid subdomain parts.
 *
 * @note Hostnames are "reversed" because DNS is "reversed".
 */
abstract class Hostname extends Struct
{
    /**
     * Create a new Hostname from a string.
     *
     * @param string $HostnameStr The hostname to parse.
     * @param string $Separator The subdomain separator or the period (\c .) by default.
     * @throws Exception HostnameStr not a string.
     * @retval array The Hostname Struct.
     *
     * @note The entire hostname is lowercased.
     */
    public static function Init( $HostnameStr,$Separator = '.' )
    {
        if( is_string($HostnameStr) === FALSE )
            throw new Exception('HostnameStr not a string.');

        if( $HostnameStr === '' )
            return static::$Skel;

        return array_reverse(explode($Separator,strtolower(trim($HostnameStr,'.'))));
    }

    /**
     * Check whether an array is a Hostname Struct.
     *
     * @param array $Subject The array to test.
     * @retval boolean TRUE if Subject is of a known structure.
     */
    public static function IsA( $Subject )
    {
        return Is::Numeric($Subject);
    }

    /**
     * Create a string from the Hostname array.
     *
     * @param array $Hostname A Hostname Struct.
     * @retval string The hostname string.
     */
    public static function ToString( $Hostname )
    {
        return implode('.',array_reverse($Hostname));
    }

    /**
     * This remaps to Append().
     */
    public static function Prepend( $Element,&$Subject )
    {
        return parent::Append(trim(trim($Element),'.'),$Subject);
    }

    /**
     * This remaps to Prepend().
     */
    public static function Append( $Element,&$Subject )
    {
        return parent::Prepend(trim(trim($Element),'.'),$Subject);
    }

    /**
     * Prepend or append a subdomain in a Hostname.
     *
     * $Needle is a string defining the change to make:
     *  - \c <subdomain: prepend the subdomain.
     *  - \c >subdomain: append the subdomain.
     *
     * @param string $Needle Direction and subdomain to add.
     * @param array $Haystack Hostname Struct.
     * @retval int The position the subdomain was added.
     * @retval NULL Operation not recognized.
     *
     * @todo This may be expanded slightly.
     */
    public static function Set( $Needle,&$Haystack )
    {
        $Needle = trim($Needle);

        if( $Needle[0] === '<' )
            return static::Prepend(ltrim($Needle,'<'),$Haystack);
        else if( $Needle[0] === '>' )
            return static::Append(ltrim($Needle,'>'),$Haystack);
        else
            return NULL;
    }

    /**
     * Search for and return the position of a sub-domain.
     *
     * @param string $Needle The sub-domain to search for.
     * @param array $Hostname The Hostname Struct to search.
     * @retval int The position of the sub-domain.
     * @retval FALSE The sub-domain was not found.
     *
     * @note The search is case-sensitive.
     */
    public static function Search( $Needle,$Hostname )
    {
        return array_search($Needle,$Hostname);
    }

    /**
     * Read one or more sub-domains from the top.
     *
     * In a hostname such as www.framewire.org, "org" is the top most sub-domain.
     *
     * @param array $Haystack Hostname Struct.
     * @param int $Limit Optional number of sub-domains to read, starting from 1.
     * @retval string The single top-most sub-domain.
     * @retval array The specified number of top-most sub-domains as a new Hostname Struct.
     */
    public static function Top( $Haystack,$Limit = 0 )
    {
        if( $Limit > 0 )
            return array_slice($Haystack,0,$Limit);
        else
            return $Haystack[0];
    }

    /**
     * Read one or more sub-domains from the bottom.
     *
     * In a hostname such as www.framewire.org, "www" is the bottom most sub-domain.
     *
     * @param array $Haystack Hostname Struct.
     * @param int $Limit Optional number of sub-domains to read, starting from 1.
     * @retval string The single bottom-most sub-domain.
     * @retval array The specified number of bottom-most sub-domains as a new Hostname Struct.
     */
    public static function Bottom( $Haystack,$Limit = 0 )
    {
        if( $Limit > 0 )
            return array_slice($Haystack,count($Haystack)-$Limit);
        else
            return $Haystack[count($Haystack)-1];
    }


    /**
     * Iterate through a \c Hostname sub-domain by sub-domain, left to right or right to left.
     *
     * This creates an array containing increasingly more or less specific versions of
     * the same hostname.
     *
     * @param string $Hostname The Hostname Struct.
     * @param boolean $Inc Iterate in increasing hostname size, i.e., most general to most specific.
     * @retval array Ordered hostname sub-domains.
     *
     * @note Each hostname returned will have a leading period and no trailing period.
     */
    public static function Order( $Hostname,$Inc = TRUE )
    {
        if( Hostname::IsA($Hostname) === FALSE )
            throw new Exception('Hostname is not a Hostname Struct');

        $P = array();
        foreach( $Hostname as $K => $V )
            $P[] = ".{$V}".($K>0?$P[$K-1]:'');

        if( $Inc === TRUE )
            return $P;
        else
            return array_reverse($P);
    }
}


/**
 * Tools for manipulating a URL.
 *
 * The structure of a URL Struct is:
 *
 *  - \c IsHTTPS: \c TRUE if the scheme is https.
 *  - \c Scheme: Typically \c http or \c https.
 *  - \c Username
 *  - \c Password
 *  - \c Hostname
 *  - \c Port
 *  - \c Path: A \c Path Struct
 *  - \c Query: A \c URLEncoded Struct
 *  - \c Fragment or \c #
 *
 * @note This does not support full URL/URI pedantics.
 */
abstract class URL extends Struct
{
    protected static $Skel = array('IsHTTPS'=>FALSE,'Scheme'=>'','Username'=>'','Password'=>'',
    							   'Hostname'=>array(),'Port'=>'','Path'=>array(),'Query'=>array(),'Fragment'=>'');

    /**
     * Create a new URL from a string.
     *
     * @param string $URLStr The URL string to parse.
     * @throws Exception URLStr not a string.
     * @throws Exception Malformed URL '$URLStr' (parse_url()).
     * @retval array The URL Struct.
     *
     * domain.com
     * domain.com/
     * domain.com/something.html
     * /something.html
     *
     * Some URLs are indeterminate, such as a domain without a period or a filename without an extension.
     *
     * @note This uses parse_url() and will prefix http:// if :// doesn't exist, and attempt detection
     *       of an absolute path (a period comes after a forward slash, if there is a forward slash).  If
     *       parse_url() cannot handle the URL, an exception is thrown.  Long story short, be mindful of
     *       what you're passing in and don't blindly rely on automatic detection of URLs vs paths.
     * @note This uses Path.
     * @note This uses URLEncoded.
     * @note Detection should work pretty well but domain.com vs filename.html isn't feasible so it's assumed a domain
     * @todo Test with oddball URLs and possibly refine per http://us3.php.net/manual/en/function.parse-url.php
     * @todo Set flag for returning based on merging current request with URLStr.
     */
    public static function Init( $URLStr )
    {
        $URL = static::$Skel;

        // empty string so return empty URL (just a root path with empty everything else)
        if( empty($URLStr) )
        {
            $URL['Path'] = Path::Init('/');
            return $URL;
        }

        if( is_string($URLStr) === FALSE )
            throw new Exception('URLStr not a string.');

        // perform some preprocess for domain vs path vs URL detection magic if there isn't a scheme
        if( strpos($URLStr,'://') === FALSE )
        {
            $p_p = strpos($URLStr,'.');
            $p_s = strpos($URLStr,'/');

            // a period before a slash, or no slash - prepend http://
            // domain.com  domain.com/  domain.com/something.html
            if( $p_p < $p_s || $p_s === FALSE )
            {
                $URLStr = "http://{$URLStr}";
            }
            // a slash before a period or slash at first character - treat as path only, leave hostname empty, and return
            // /something.html
            else if( $p_s < $p_p || $p_s === 0 )
            {
                $URL['Path'] = Path::Init($URLStr);
                $URL['Hostname'] = Hostname::Init('');
                $URL['Query'] = URLEncoded::Init('');
                return $URL;
            }
        }

        if( ($T = @parse_url(trim($URLStr))) === FALSE )
            throw new Exception("Malformed URL '$URLStr' (parse_url()).");

        $URL['Scheme'] = isset($T['scheme'])===TRUE?strtolower($T['scheme']):$URL['Scheme'];

        // If the scheme is https then it IsHTTPS = TRUE
        $URL['IsHTTPS'] = $URL['Scheme']==='https'?TRUE:$URL['IsHTTPS'];

        $URL['Hostname'] = isset($T['host'])===TRUE?Hostname::Init($T['host']):$URL['Hostname'];
        $URL['Port'] = isset($T['port'])===TRUE?$T['port']:$URL['Port'];

        $URL['Username'] = isset($T['user'])===TRUE?$T['user']:$URL['Username'];
        $URL['Password'] = isset($T['pass'])===TRUE?$T['pass']:$URL['Password'];

        $URL['Path'] = Path::Init(isset($T['path'])===TRUE?$T['path']:'');
        $URL['Query'] = isset($T['query'])===TRUE?URLEncoded::Init($T['query']):$URL['Query'];

        $URL['Fragment'] = isset($T['fragment'])===TRUE?$T['fragment']:$URL['Fragment'];

        return $URL;
    }

    /**
     * Create a new URL from individual parts.
     *
     * @param string $Scheme Typically http or https (:// is trimmed).
     * @param string $Hostname Hostname.
     * @param string|array $Path Path string or Path Struct.
     * @param string|array $Query Query string or URLEncoded Struct.
     * @param string|NULL $Port Optional port.
     * @param string|NULL $Username Optional username.
     * @param string|NULL $Password Optional password.
     * @param string|NULL $Fragment Optional fragment.
     * @retval array The URL.
     *
     * @note This uses the Set*() family of methods.
     * @note Explicitly setting a username/password in a URL may be incompatible with some browsers, like IE.
     */
    public static function InitParts( $Scheme,$Hostname,$Path,$Query,$Port = NULL,$Username = NULL,$Password = NULL,$Fragment = NULL )
    {
        $URL = static::$Skel;

        static::SetScheme($Scheme,$URL);
        static::SetHostname($Hostname,$URL);
        static::SetPath($Path,$URL);
        static::SetQuery($Query,$URL);

        if( $Port !== NULL )
            static::SetPort($Port,$URL);
        if( $Username !== NULL )
            static::SetUsername($Username,$URL);
        if( $Password !== NULL )
            static::SetPassword($Password,$URL);
        if( $Fragment !== NULL )
            static::SetFragment($Fragment,URL);

        return $URL;
    }

    /**
     * The Set*() family of methods change parts of a URL Struct.
     */

    /**
     * Change the scheme of a URL.
     *
     * @param string $Scheme A string.
     * @param array $URL A URL Struct.
     * @retval void
     *
     * @note This will affect the URL's IsHTTPS value.
     */
    public static function SetScheme( $Scheme,&$URL )
    {
        $URL['Scheme'] = strtolower(trim(trim($Scheme,'://')));
        $URL['IsHTTPS'] = $URL['Scheme']==='https'?TRUE:FALSE;
    }

    /**
     * Change the Hostname of a URL.
     *
     * @param string|array $Hostname A string or Hostname Struct to set.
     * @param array $URL A URL Struct.
     * @throws Exception Hostname not a string or Hostname Struct.
     * @retval void
     */
    public static function SetHostname( $Hostname,&$URL )
    {
        if( is_string($Hostname) === TRUE )
            $URL['Hostname'] = Hostname::Init($Hostname);
        else if( Hostname::IsA($Hostname) === TRUE )
            $URL['Hostname'] = $Hostname;
        else
            throw new Exception("Hostname not a string or Hostname Struct.");
    }

    /**
     * Change the Path of a URL.
     *
     * @param string|array $Path A string or Hostname Struct to set.
     * @param array $URL A URL Struct.
     * @throws Exception Path not a string or Path Struct.
     * @retval void
     */
    public static function SetPath( $Path,&$URL )
    {
        if( is_string($Path) === TRUE )
            $URL['Path'] = Path::Init($Path);
        else if( Path::IsA($Path) === TRUE )
            $URL['Path'] = $Path;
        else if( $Path !== NULL )
            throw new Exception('Path not a string or Path Struct.');
    }

    /**
     * Change the Query of a URL.
     *
     * @param string|array $Query A string or URLEncoded Struct to set.
     * @param array $URL A URL Struct.
     * @throws Exception Query not a string or URLEncoded Struct.
     * @retval void
     */
    public static function SetQuery( $Query,&$URL )
    {
        if( is_string($Query) === TRUE )
            $URL['Query'] = URLEncoded::Init($Query);
        else if( URLEncoded::IsA($Query) === tRUE )
            $URL['Query'] = $Query;
        else if( $Query !== NULL )
            throw new Exception("Query not a string or URLEncoded Struct.");
    }

    /**
     * Change the Port of a URL.
     *
     * @param string|int $Port A string or integer.
     * @param unknown_type $URL A URL Struct.
     * @retval void
     *
     * @note The port is always converted to a string.
     * @note If the port is 80 or 443, it is set as the empty string.
     */
    public static function SetPort( $Port,&$URL )
    {
        if( in_array((string)$Port,array('','80','443')) === TRUE )
            $URL['Port'] = '';
        else
            $URL['Port'] = (string) $Port;
    }

    /**
     * Change the Username of a URL.
     *
     * @param string $Username A string.
     * @param array $URL A URL Struct.
     * @retval void
     *
     * @note Explicitly setting a username in a URL may be incompatible with some browsers, like IE.
     */
    public static function SetUsername( $Username,&$URL )
    {
        $URL['Username'] = $Username===NULL?$URL['Username']:$Username;
    }

    /**
     * Change the Password of a URL.
     *
     * @param string $Password A string.
     * @param array $URL A URL Struct.
     * @retval void
     *
     * @note A Username check is not done.
     * @note Explicitly setting a password in a URL may be incompatible with some browsers, like IE.
     */
    public static function SetPassword( $Password,&$URL )
    {
        $URL['Password'] = $Password===NULL?$URL['Password']:$Password;
    }

    /**
     * Change or delete the Fragment of a URL.
     *
     * @param string $Fragment Fragment or a single # to delete an existing one.
     * @param array $URL A URL Struct.
     * @retval void
     */
    public static function SetFragment( $Fragment,&$URL )
    {
        if( $Fragment === '#' )
            $URL['Fragment'] = '';
        else if( $Fragment !== NULL )
            $URL['Fragment'] = ltrim($Fragment,'#');
    }

    /**
     * Create a string from the URL array, depending on the URL parts present.
     *
     * @param array $URL The URL array.
     * @throws Exception URL is not URL Struct.
     * @retval string URL string.
     *
     * @note Logic exists to handle an empty hostname in which case scheme/port/username/password isn't included
     *       and thus a path-only "URL" is returned.
     * @note Explicitly setting a username in a URL may be incompatible with some browsers, like IE.
     * @todo At some point we may use the HTTP PECL,
     * 		 http://us2.php.net/manual/en/function.http-build-url.php
     */
    public static function ToString( $URL )
    {
        $Str = '';
        if( !empty($URL['Hostname']) )
        {
            $Str = $URL['Scheme']!==''?"{$URL['Scheme']}://":'';
            if( !empty($URL['Username']) )
                $Str .= static::AuthorityToString($URL['Username'],$URL['Password']);

            $Str .= Hostname::ToString($URL['Hostname']).($URL['Port']===''?'':":{$URL['Port']}");
        }

        // if a hostname is present, ensure a / for relative paths - otherwise use what Path has
        $Str .= (!empty($Str)&&empty($URL['Path']['IsAbs'])?'/':'').Path::ToURLString($URL['Path']);
        $Str .= empty($URL['Query'])?'':URLEncoded::ToString($URL['Query']);
        $Str .= $URL['Fragment']===''?'':'#'.rawurlencode($URL['Fragment']);

        return $Str;
    }

    /**
     * Change parts of a URL Struct.
     *
     * $Needle is a change string or array of strings defining the changes to make:
     *  - \c >segment: append a segment to the path.
     *  - \c <segment: prepend a segment to the path.
     *  - \c ?key=value: set a key/value in the query string.
     *  - \c ?key=: delete a key/value in the query string.
     *  - \c ?: delete entire query string.
     *  - \c \#fragment: set the URL fragment.
     *  - \c #: delete the URL fragment.
     *
     * $Needle may also combine segment, ?key=value and \#fragment change strings:
     *  - \c >new-segment?login=1&register=&redirect=1
     *
     * This would append a new path segment, set login and redirect query variables
     * to 1, and remove the register variable.
     *
     * The array syntax for URLEncoded::Set() is also supported.
     *
     * @param string $Needle A change to make.
     * @param array $Needle An array of change to make.
     * @param array &$Haystack URL Struct.
     * @retval void
     *
     * @todo This needs optimization and perhaps better support, including appending/prepending
     * more than one path segment at a time (i.e. from LinkPage).
     */
    public static function Set( $Needle,&$Haystack )
    {
        foreach( (array) $Needle as $K => $V )
        {
            if( is_array($V) )
            {
                URLEncoded::Set($V,$Haystack['Query']);
                continue;
            }
            else if( !is_int($K) )
            {
                URLEncoded::Set(array(array($K=>$V)),$Haystack['Query']);
                continue;
            }

            $V2 = explode('#',$V);
            if( isset($V2[1]) )
                static::SetFragment($V2[1],$Haystack);

            $V2 = explode('?',$V2[0]);
            if( isset($V2[1]) )
                URLEncoded::Set($V2[1],$Haystack['Query']);

            if( !empty($V2[0]) )
            {
                if( ($V2[0][0] === '>' || $V2[0][0] === '<') )
                {
                    Path::Set($V2[0],$Haystack['Path']);
                    $Haystack['Path']['IsAbs'] = TRUE;
                }
                else
                {
                    trigger_error("URL::Set() Unrecognized change string '{$V}'");
                }
            }
        }
    }

    /**
     * Read the full hostname as a string.
     *
     * @param array $URL URL Struct.
     * @retval string The hostname string.
     */
    public static function Hostname( $URL )
    {
        return Hostname::ToString($URL['Hostname']);
    }

    /**
     * Read the full path as a string.
     *
     * @param array $URL URL Struct.
     * @retval string The path string.
     */
    public static function Path( $URL )
    {
        return Path::ToURLString($URL['Path']);
    }

    /**
     * Helper for creating a URL authority part from a username and password.
     *
     * @param string|NULL $Username The username, an empty string, or NULL.
     * @param string|NULL $Password The password, an empty string, or NULL.
     * @retval string URL authority string, which may be an empty string.
     *
     * @note A password without a username will return an empty string.
     * @note Explicitly setting a username in a URL may be incompatible with some browsers, like IE.
     */
    public static function AuthorityToString( $Username,$Password )
    {
        if( $Username !== NULL && $Username !== '' )
            return rawurlencode($Username).($Password!==''&&$Password!==NULL?':'.rawurlencode($Password).'@':'@');
        else
            return '';
    }
}


/**
 * Tools for manipulating encoded key/value pairs, such as GET query strings and POST data.
 *
 * The structure of a URLEncoded Struct is that of one or more key/value pairs.
 *
 * @note This should not be used for multipart/form-data.
 * @note This uses http_build_query() with PHP_QUERY_RFC3986 (rawurlencode()).
 * @todo Provide functionality for appending/combining key/value pairs before/after one another.
 * @todo When upgraded to PHP 5.4, use PHP_QUERY_RFC3986 directive.
 */
abstract class URLEncoded extends Struct
{
    /**
     * Create a new URLEncoded from a string.
     *
     * @param string $URLEncStr The URL encoded string to parse.
     * @retval array The URLEncoded.
     * @throws Exception URLEncStr not a string.
     *
     * @note This uses parse_str().
     * @todo We may want to do some normalization - keys may be ints (?45=something).
     */
    public static function Init( $URLEncStr )
    {
        if( is_string($URLEncStr) === FALSE )
            throw new Exception('URLEncStr not a string.');

        $Q = array();
        parse_str($URLEncStr,$Q);
        return $Q;
    }

    /**
     * Add or remove key/values in a URLEncoded Struct.
     *
     * $Needle is change string, an array of change strings, or an array
     * of associative array key/value pairs, defining the changes to make:
     *  - \c ?key=value&key1=value1: set the key/value pairs from a string.  setting empty will delete the key.
     *  - \c ?: remove all key/values
     *  - \c array('key'=>'value'): set the key/value from an array
     *  - \c array('key'=>NULL): remove the key/value, if it exists
     *  - \c array(): remove all key/values
     *
     * @param array $Needle An array of key/values as strings or arrays.
     * @param string $Needle A key=value change string.
     * @param array &$Haystack URLEncoded Struct.
     * @retval void
     */
    public static function Set( $Needle,&$Haystack )
    {
        foreach( (array) $Needle as $K => $V )
        {
            if( empty($V) || $V === '?' )
            {
                $Haystack = array();
                continue;
            }

            if( is_string($V) )
            {
                parse_str(ltrim($V,'?'),$V2);
            }
            else if( is_array($V) )
            {
                $V2 = $V;
            }

            foreach( $V2 as $I => $J )
            {
                if( isset($Haystack[$I]) && empty($J) )
                    static::Del($I,$Haystack);
                else
                    $Haystack[$I] = $J;
            }
        }
    }

    /**
     * Create a string from the URLEncoded Struct.
     *
     * @param array $URLEncoded Array of key/value pairs.
     * @param string $Prefix Optional string prefix.
     * @retval string The URL encoded string.
     *
     * @note This uses http_build_query().
     * @todo And one or more levels of recursion, which would flatten into a single string, whereas
     * 		 http_build_query() currently keeps them multi-dimensional.
     */
    public static function ToString( $URLEncoded,$Prefix = '?' )
    {
        return ($Tmp = http_build_query($URLEncoded))===''?'':"{$Prefix}{$Tmp}";
        // return http_build_query($URLEncoded,NULL,'&',PHP_QUERY_RFC3986);
    }
}

/*
 * A unit of runtime configuration for a Wireable object.
 *
 * A Directive is a key/value pair that a Page applies to a Wireable
 * object, using ApplyDirective(), just before a Page executes.
 * Only the object's internal behavior dictates what effect the
 * Directive has.
abstract class Directive extends Struct
{
    protected static $Skel = array('Name'=>'','Key'=>'','Value'=>NULL);


     * Create a new Directive.
     *
     * The Directive may be supplied as three parameters, a three part
     * comma-deliminated string, or a three element numeric array.  The
     * following formats are accepted:
     *
     * - name,Key,Value
     * - name,Key
     * - array('name','Key',Value)
     * - array('name','Key')
     *
     * Where name is the name of the Wire()'d object.  Value will
     * default to NULL when not specified.
     *
     * @param string|array $Name The Name of the Wire()'d object, or a Directive
     *                           string/array definition.
     * @param NULL|string $Key The key or unused if a string/array definition is given.
     * @param NULL|mixed $Value The value or unused if a string/array definition is given.
     * @retval array The Directive.
     * @throws Exception Invalid Directive array definition with COUNT elements.
     * @throws Exception Invalid Directive string definition with COUNT elements.
     * @throws Exception Invalid Directive Name.
     *
     * @note Name is case sensitive (all Wire()'d objects have a lowercase name).
    public static function Init( $Name,$Key = NULL,$Value = NULL )
    {
        // Array definition
        if( is_array($Name) === TRUE )
        {
            if( count($Name) === 3 )
                list($Name,$Key,$Value) = array_values($Name);
            else if( count($Name) === 2 )
                list($Name,$Key) = $Name;
            else
                throw new Exception('Invalid Directive array definition with '.count($Name).' elements.');
        }
        // String definition
        else if( $Key === NULL )
        {
            $Name = explode(',',$Name);
            if( count($Name) > 3 || count($Name) < 2 )
                throw new Exception('Invalid Directive string definition with '.count($Name).' elements.');
            else
            {
                $Key = $Name[1];
                $Value = $Name[2];
                $Name = $Name[0];
            }
        }

        $Directive = static::$Skel;
        $Directive['Name'] = $Name;
        $Directive['Key'] = $Key;
        $Directive['Value'] = $Value;

        return $Directive;
    }
}
*/


/**
 * Base class to encapsulate key/value pairs and their getter/setter logic
 * for local memory-resident variables.
 *
 * A KV is a data structure and group of methods for iteration, getters,
 * setters, and specialized functionality, together implementing Framewire's
 * MVC <b>m</b>odel.
 *
 * @note Anywhere __call() is implemented, should throw an exception if the called
 *       method isn't know, rather than return silently.  Otherwise things get very
 *       confusioning.  And this comment should be moved somewhere else.
 */
class KeyValueSet implements KVS
{
    /**
     * Key/value pairs that comprise the KV's data.
     */
    protected $KV = array();

    /**
     * The number of key/value pairs in this KV.
     *
     * @note This and {@link $KVPosition} are used in a just-in-time fashion for iteraion.
     * 		 They are not kept current during get/set/unset operations.
     */
    protected $KVLength = 0;

    /**
     * The current position within {@link $KVLength}.
     *
     * @see $KVLength
     */
    protected $KVPosition = 0;


    /**
     * Create a new KV object.
     *
     * If \c ArrayRef isn't supplied, the KV will reference it's own empty array.
     *
     * @param array|NULL &$ArrayRef Reference to an array which contains
     * 								the KV's key/value pairs.
     * @throws KV must reference an array, TYPE given.
     */
    public function __construct( &$ArrayRef = NULL )
    {
        if( is_array($ArrayRef) === TRUE )
            $this->KV = &$ArrayRef;
        else if( $ArrayRef !== NULL )
            throw new Exception('KV must reference an array, '.gettype($ArrayRef).' given.');
    }

    /**
     * Key/value getter using property overloading.
     *
     * @param integer|string $Key The element's key to get.
     * @retval mixed|NULL The element's value or NULL if \c Key isn't __isset().
     */
    public function __get( $Key )
    {
        return $this->__isset($Key)===TRUE?$this->KV[$Key]:NULL;
    }

    /**
     * Key/value setter using property overloading.
     *
     * If \c Key exists, it's value is silently overwritten.
     *
     * @param integer|string $Key The element's key to set.
     * @param mixed $Value The element's value to set.
     * @retval void
     */
    public function __set( $Key,$Value )
    {
        $this->KV[$Key] = $Value;
    }

    /**
     * Determine if a key is set using property overloading.
     *
     * For performance, isset() is first used to check whether \c Key
     * is set (non-NULL).  This check is case-sensitive and loosely typed.
     *
     * If isset() returns FALSE, array_key_exists() is used
     * to check if \c Key is set, but is set to NULL.  This check is
     * case-sensitive and loosley typed.
     *
     * @param integer|string $Key The element's key to check.
     * @retval boolean \c TRUE if the \c Key exists.
     *
     * @note Tempting PHP's loosely typed guesswork can lead to painfully subtle
     * 	     bugs - use only non-numeric strings or actual integers as keys.
     */
    public function __isset( $Key )
    {
        return (isset($this->KV[$Key])===TRUE?TRUE:array_key_exists($Key,$this->KV));
    }

    /**
     * Unset a key/value pair using property overloading.
     *
     * @param integer|string $Key The element's key to unset.
     * @retval boolean \c TRUE if \c Key was found.
     * @todo Test to ensure this works considering CopyOnClone and
     * 		 referencing external arrays.
     * @see Clear()
     */
    public function __unset( $Key )
    {
        if( $this->__isset($Key) === TRUE )
        {
            $this->KV[$Key] = NULL;
            unset($this->KV[$Key]);
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    /**
     * @retval integer The number of key/value pairs.
     * @note Implement SPL's Countable interface.
     */
    public function count()
    {
        return count($this->KV);
    }

    /**
     * @retval void
     * @note Implement SPL's Iterator interface.
     * @note Uses {@link $KVPosition} and {@link $KVLength}.
     */
    public function rewind()
    {
        $this->KVLength = count($this->KV);
        $this->KVPosition = 0;
        reset($this->KV);
    }

    /**
     * @retval mixed
     * @note Implement SPL's Iterator interface.
     * @note Use __get() in extending classes to maintain the processing behavior it does.
     */
    public function current()
    {
        return $this->__get(key($this->KV));
    }

    /**
     * @retval void
     * @note Implement SPL's Iterator interface.
     */
    public function key()
    {
        return key($this->KV);
    }

    /**
     * @retval void
     * @note Implement SPL's Iterator interface.
     * @note Uses {@link $KVPosition}.
     */
    public function next()
    {
        ++$this->KVPosition;
        next($this->KV);
    }

    /**
     * @retval boolean
     * @note Implement SPL's Iterator interface.
     * @note Uses {@link $KVPosition} and {@link $KVLength}.
     */
    public function valid()
    {
        return ($this->KVPosition < $this->KVLength);
    }

    /**
     * @retval mixed
     * @note Implement SPL's ArrayAccess interface.
     */
    public function offsetGet( $Key )
    {
        return $this->__get($Key);
    }

    /**
     * @retval void
     * @note Implement SPL's ArrayAccess interface.
     */
    public function offsetSet( $Key,$Value )
    {
        $this->__set($Key,$Value);
    }

    /**
     * @retval boolean
     * @note Implement SPL's ArrayAccess interface.
     */
    public function offsetExists( $Key )
    {
        return $this->__isset($Key);
    }

    /**
     * @retval void
     * @note Implement SPL's ArrayAccess interface.
     */
    public function offsetUnset( $Key )
    {
        $this->__unset($Key);
    }

    /**
     * Implement Wireable interface, setting a key/value pair as a \c Directive.
     * @param string $Key The name of the key to set.
     * @param mixed $Value The value to set.
     * @retval void
     */
    public function ApplyDirective( $Key,$Value )
    {
        $this->KV[$Key] = $Value;
    }

    /**
     * Set the {@link $KV} as a reference.
     * @retval void
     */
    public function Import( &$ArrayRef = NULL )
    {
        $this->KV = &$ArrayRef;
    }

    /**
     * Return the {@link $KV}.
     * @retval array
     */
    public function Export()
    {
        return $this->KV;
    }
}

